/*
1. 업 캐스팅 (up-casting)
	- 파생 클래스의 객체를 기본 클래스의 포인터로 가리키는 것
	  EX) ColorPoint cp;
	   	  ColorPoint *pDer = &cp;
		  Point* pBase = pDer; //업캐스팅
	  ※업 캐스팅한 기본 클래스의 포인터로는 기본 클래스의 멤버만 접근 가능

2. 다운 캐스팅 (down-casting)
	- 기본 클래스 포인터가 가리키는 객체를 파생 클래스의 포인터로 가리키는 것
	- 업 캐스팅과는 달리 명시적으로 형 변환을 지정해야함
	  EX) pDer = (ColorPoint *)pBase; //다운캐스팅 _ 강제 형 변환 필수
		  pDer->setColor("Red") //정상 컴파일
		  pDer->showColorPoint(); //정상 컴파일

3. protected 접근 지정
	- 파생 클래스에게 접근을 허용, 다른 클래스나 외부 함수에서는 접근 금지.

4. 상속의 생성자, 소멸자
	- 파생 클래스의 객체가 생성될 때, 파생 클래스의 생성자와 기본 클래스의 생성자가 모두 실행되는가? 
	  아니면 파생 클래스의 생성자만 실행되는가?
		
		둘 다 실행됨. 각자 자신 클래스의 멤버를 초기화거나 필요한 초기 작업을 수행함.

	- 파생 클래스의 생성자와 기본 클래스의 생성자 중에서 어떤 생성자가 먼저 실행되는가?
		
		기본 클래스의 생성자가 먼저 실행됨.

	EX) class A, class B : public A, class C : public B
		생성 순서 : A -> B -> C
		소멸 순서 : C -> B -> A

5. 생성자 호출
	- 컴파일러에 의해 묵시적으로 기본 클래스의 생성자가 선택되는 경우
		파생 클래스를 작성한 개발자가 기본 클래스의 생성자를 선택하지 않은 경우, 컴파일러는 
		기본 클래스의 기본 생성자가 호출되도록 묵시적으로 선택.
		※ 기본 생성자가 없으면 컴파일 오류가 발생
	- 명시적인 기본 클래스의 생성자 선택
		
6. 상속의 종류 (public, protected, private)
	- public : 기본 클래스를 public으로 상속받으면, 기본 클래스의 protected, public 멤버들은
			   접근 지정 변경 없이 파생 클래스에 그대로 상속 확장됨.
	- protected : 기본 클래스를 protected로 상속받으면, 기본 클래스의 protected, public 멤버들은
				  모두 protected 접근 지정으로 변경되어 파생 클래스에 상속 확장됨.
	- private : 기본 클래스를 private으로 상속받으면, 기본 클래스의 protected, public 멤버들은
				  모두 private 접근 지정으로 변경되어 파생 클래스에 상속 확장됨.

7. 다중 상속 (multiple inheritance)
	- 문제점 : 상속되는 과정에서 한 객체의 한 변수가 2개가 존재하게 될 시에 컴파일 오류가 발생
		=> p395 참고
	
	- 해결 : 가상 상속

8. 가상 상속
	- virtual 키워드 사용 : 컴파일러에게 파생 클래스의 객체가 생성될 때 기본 클래스의 멤버 공간을 
							오직 한 번만 할당하고, 이미 할당되어 있다면 그 공간을 공유하도록 지시.
							=> 가상 기본 클래스의 멤버 공간은 오직 한 번만 생성.
	- 



*/